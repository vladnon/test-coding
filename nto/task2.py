import cv2
import numpy as np
# читаем картинку (я залила папку в свой новый проект, отредачь как будет у тебя)
orig_img = cv2.imread('images/IMG_20240823_174118.jpg')

# обработка исключения
assert orig_img is not None, "File is not found"

# Получается размеры с картинки, см. документацию
height, width = orig_img.shape[:2]

# Масштабирование картинки, см.документацию. Вообще, по идее, это нужно лишь для комфортного вывода
# И отдалки, по факту, для работы кода не нужно даже просматриавать картинку (это только нам нужно)
res_img = cv2.resize(orig_img, (width//4, height//4),
                     interpolation=cv2.INTER_CUBIC)

# Переводим в оттенки серого
gray = cv2.cvtColor(res_img, cv2.COLOR_BGR2GRAY)

# Размытие по Гауссу, чтобы убрать шум. Хз, насколько целесообразно, но рекомендовано это делать
blur = cv2.GaussianBlur(gray, (5, 5), 0)

# Пороговая обработка в бинарное изображение.
# Значения 73 и 100 подобраны опытным путем. 73 выделяет контуры двух объектов и мне надо было, чтобы была верхняя грань куба - квадрат (без остальных граней)
# и более понятный контур микросд флешки (кокретно к данной картинке), чтобы был корректно посчитатан размер объекта.
# 100 - значение яркости/контрастности? на 255 это белый, но когда выделенные зоны полностью белые, то ту же флешку определяет меньшим размером, поэтому, понизив
# значение, я добилась того, что размер флешки считывается корректно
# пробывала добавлять алгоритм otsu (см.документацию), он типа сам высчитывет параметры, но выделяет весь куб, а не одну грань. Хотя хз
# Я пробывала со значением яркости 255, мб стоило 100 поставить, и будет окей. Потому что на других картинках могут этим параметры не сработать
# Поэтому, поэксперементируй
_, thresh = cv2.threshold(blur, 73, 100, cv2.THRESH_BINARY_INV)

# Находим контуры.
contours, _ = cv2.findContours(
    thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Обработка исключения. Если найдено меньше двух контуров, то сравнивать мы не можем .
if len(contours) < 2:
    print("Find one or null object")
    # Добавить буллиан флаг, автоматом должен быть ложью. Ибо сравнивать нечего.
    print('False')
    exit()

# Контуры обязателоьно нужно отсортировать от большего к меньшему перед сравнением
contours = sorted(contours, key=cv2.contourArea, reverse=True)

# Выбор двух самых больших контуров.
contour1 = contours[0]
contour2 = contours[1]

# Создаем копию картинки. (Нужно только для отладки кода)
output = res_img.copy()
# Прямоугольник по направлению объекта


def get_rect(contour):
    # Возвращает (центроиды (x,y), (ширина, высота), угол поворота)
    rect = cv2.minAreaRect(contour)
    box = cv2.boxPoints(rect)        # Получает четыре вершины прямоугольника
    box = np.int0(box)               # Округляет координаты до целых чисел
    return rect, box


# Получение повёрнутых прямоугольников для обоих контуров
rect1, box1 = get_rect(contour1)
rect2, box2 = get_rect(contour2)

# Рисование повёрнутых прямоугольников на изображении. Для отладки кода
# Зеленый для первого объекта
cv2.drawContours(output, [box1], 0, (0, 255, 0), 2)
cv2.drawContours(output, [box2], 0, (255, 0, 0),
                 2)  # Синий для второго объекта


# Отображение результатов. Только для отладки кода
cv2.imshow('Thresholded Image', thresh)
cv2.imshow('Detected Objects', output)

# Вычиялем размеры.
area1 = rect1[1][0] * rect1[1][1]
area2 = rect2[1][0] * rect2[1][1]

print(f"Area 1: {area1}")
print(f"Area 2: {area2}")

# Сравнение. Тут можно добавить булеан флаг.
if area1 > area2:
    print("True")
elif area1 < area2:
    print("False")
else:
    print("True")

# return flag
cv2.waitKey(0)  # Нужно для отладки
cv2.destroyAllWindows()
